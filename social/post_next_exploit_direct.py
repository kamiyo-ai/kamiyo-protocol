#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Post next exploit directly from database (bypassing API)
Usage: python3 social/post_next_exploit_direct.py
"""

import os
import sys
import sqlite3
import logging
from datetime import datetime
from dotenv import load_dotenv

# Add parent directory to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from social.models import ExploitData
from social.platforms.x_twitter import XTwitterPoster
from social.analysis.report_generator import ReportGenerator
from social.analysis.formatters import ReportFormatter
from social.analysis.claude_enhancer import ClaudeEnhancer
from social.analysis.data_models import ReportFormat

# Load environment
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def get_next_unposted_exploit(db_path, min_amount=500000):
    """Get the next exploit from database that hasn't been posted"""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # Get latest exploit meeting threshold
    # Note: We're just getting the latest one - in production you'd track which have been posted
    cursor.execute("""
        SELECT id, tx_hash, protocol, chain, amount_usd, timestamp, source, source_url, description
        FROM exploits
        WHERE amount_usd >= ?
        ORDER BY timestamp DESC
        LIMIT 1
    """, (min_amount,))

    row = cursor.fetchone()
    conn.close()

    if not row:
        return None

    # Convert to ExploitData
    return ExploitData(
        tx_hash=row[1] or f"generated-{row[0]}",
        protocol=row[2],
        chain=row[3],
        loss_amount_usd=row[4],
        timestamp=datetime.fromisoformat(row[5]) if row[5] else datetime.utcnow(),
        source=row[6],
        source_url=row[7],
        description=row[8],
        exploit_type="Unknown",  # Would need to extract from description
        recovery_status="Unknown"
    )

def main():
    """Post the next exploit from database"""

    db_path = "/Users/dennisgoslar/Projekter/kamiyo/data/kamiyo.db"

    # Get next exploit
    logger.info("Fetching next exploit from database...")
    min_amount = float(os.getenv('SOCIAL_MIN_AMOUNT_USD', 500000))
    exploit = get_next_unposted_exploit(db_path, min_amount)

    if not exploit:
        logger.error(f"No exploits found meeting ${min_amount:,.0f} threshold")
        return

    logger.info(
        f"Found exploit: {exploit.protocol} "
        f"(${exploit.loss_amount_usd:,.0f}) on {exploit.chain}"
    )

    # Initialize X/Twitter poster
    twitter_config = {
        'api_key': os.getenv('X_API_KEY'),
        'api_secret': os.getenv('X_API_SECRET'),
        'access_token': os.getenv('X_ACCESS_TOKEN'),
        'access_secret': os.getenv('X_ACCESS_SECRET'),
        'bearer_token': os.getenv('X_BEARER_TOKEN')
    }

    if not all([twitter_config['api_key'], twitter_config['api_secret'],
                twitter_config['access_token'], twitter_config['access_secret']]):
        logger.error("X/Twitter credentials not configured in .env")
        return

    poster = XTwitterPoster(twitter_config)
    report_gen = ReportGenerator()
    enhancer = ClaudeEnhancer()

    # Generate report
    logger.info("Generating exploit report...")
    report = report_gen.analyze_exploit(
        exploit,
        report_format=ReportFormat.MEDIUM,
        include_historical=True
    )

    # Convert timeline to dict format for Claude
    timeline_dicts = [
        {
            'timestamp': event.timestamp,
            'time': event.timestamp.strftime('%H:%M:%S UTC'),
            'description': event.description
        }
        for event in report.timeline
    ]

    # Generate Twitter thread
    logger.info("Generating Twitter thread with Claude AI...")
    twitter_thread = enhancer.generate_twitter_thread(
        exploit_data={
            'protocol': exploit.protocol,
            'chain': exploit.chain,
            'loss_amount_usd': exploit.loss_amount_usd,
            'exploit_type': exploit.exploit_type,
            'source': exploit.source or 'External sources'
        },
        timeline=timeline_dicts,
        impact=report.impact,
        historical_context=report.historical_context,
        engagement_hooks=report.engagement_hooks
    )

    logger.info(f"Generated {len(twitter_thread)} tweet thread")
    for i, tweet in enumerate(twitter_thread, 1):
        logger.info(f"Tweet {i} ({len(tweet)} chars): {tweet[:80]}...")

    # Post to X/Twitter
    logger.info("Posting to X/Twitter...")
    result = poster.post_thread(twitter_thread)

    if result:
        logger.info("✅ Successfully posted to X/Twitter!")
        logger.info(f"Posted {len(twitter_thread)} tweets")
    else:
        logger.error("❌ Failed to post to X/Twitter")

if __name__ == "__main__":
    main()
