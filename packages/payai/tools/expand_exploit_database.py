#!/usr/bin/env python3
"""
Exploit Database Expansion
Add 20+ more historical exploits to reach 30+ total
"""

import json
from datetime import datetime
from pathlib import Path

# Additional 20 major exploits to add
NEW_EXPLOITS = [
    {
        'id': 'CURVE_DAO_2020',
        'protocol': 'Curve DAO',
        'date': '2020-08-',
        'amount_usd': 0,  # Attempted, prevented
        'attack_type': 'Reentrancy',
        'pattern': 'reentrancy',
        'vulnerable_code_pattern': 'mint() + withdraw() reentrancy loop',
        'description': 'Attempted reentrancy on Curve DAO minting. Prevented by community.',
        'root_cause': 'Reentrancy in mint function before state update',
        'prevention': 'ReentrancyGuard, checks-effects-interactions'
    },
    {
        'id': 'BEANSTALK_2022',
        'protocol': 'Beanstalk Farms',
        'date': '2022-04-17',
        'amount_usd': 182000000,
        'attack_type': 'Governance Attack',
        'pattern': 'governance_attack',
        'vulnerable_code_pattern': 'Flash loan → vote → drain treasury',
        'description': 'Flash loan to gain voting power, passed malicious proposal, drained treasury',
        'root_cause': 'No time-lock on governance, flash loan voting',
        'prevention': 'Voting time-lock, flash loan protection, quadratic voting'
    },
    {
        'id': 'HARMONY_BRIDGE_2022',
        'protocol': 'Harmony Horizon Bridge',
        'date': '2022-06-23',
        'amount_usd': 100000000,
        'attack_type': 'Private Key Compromise',
        'pattern': 'access_control',
        'vulnerable_code_pattern': '2-of-5 multisig compromised',
        'description': 'Attackers compromised 2 private keys of 5-multisig bridge validators',
        'root_cause': 'Insufficient key security, low multisig threshold',
        'prevention': 'Higher threshold (3-of-5 or 4-of-7), HSM storage'
    },
    {
        'id': 'WINTERMUTE_2022',
        'protocol': 'Wintermute',
        'date': '2022-09-20',
        'amount_usd': 162000000,
        'attack_type': 'Address Collision',
        'pattern': 'access_control',
        'vulnerable_code_pattern': 'Vanity address without proper deployment checks',
        'description': 'Used Profanity for vanity address, attacker found private key collision',
        'root_cause': 'Weak vanity address generator (Profanity vulnerability)',
        'prevention': 'Use secure address generation, verify deployment bytecode'
    },
    {
        'id': 'BADGER_DAO_2021',
        'protocol': 'Badger DAO',
        'date': '2021-12-02',
        'amount_usd': 120000000,
        'attack_type': 'Frontend Attack',
        'pattern': 'access_control',
        'vulnerable_code_pattern': 'Malicious script injected approving attacker',
        'description': 'Compromised Cloudflare API key, injected malicious approval script',
        'root_cause': 'Frontend compromise, unlimited approvals',
        'prevention': 'Limited approvals, CSP headers, API key rotation'
    },
    {
        'id': 'RARI_CAPITAL_2022',
        'protocol': 'Rari Capital Fuse',
        'date': '2022-04-30',
        'amount_usd': 80000000,
        'attack_type': 'Reentrancy',
        'pattern': 'reentrancy',
        'vulnerable_code_pattern': 'ERC777 token reentrancy on withdraw',
        'description': 'Used ERC777 hooks to reenter withdraw before balance update',
        'root_cause': 'External call before state update, ERC777 callback',
        'prevention': 'Checks-effects-interactions, ReentrancyGuard'
    },
    {
        'id': 'DEUS_FINANCE_2022',
        'protocol': 'Deus Finance',
        'date': '2022-03-16',
        'amount_usd': 3000000,
        'attack_type': 'Flash Loan Price Manipulation',
        'pattern': 'flash_loan_price_manipulation',
        'vulnerable_code_pattern': 'getReserves() price without TWAP',
        'description': 'Flash loan to manipulate LP token price, borrowed against inflated collateral',
        'root_cause': 'Spot price oracle, no TWAP',
        'prevention': 'TWAP oracle, Chainlink, multi-source price feeds'
    },
    {
        'id': 'INVERSE_FINANCE_2022',
        'protocol': 'Inverse Finance',
        'date': '2022-04-02',
        'amount_usd': 15600000,
        'attack_type': 'Oracle Manipulation',
        'pattern': 'oracle_manipulation',
        'vulnerable_code_pattern': 'Relied on Keep3r oracle for single asset',
        'description': 'Manipulated Keep3r oracle price, borrowed max, dumped tokens',
        'root_cause': 'Single oracle source, low liquidity asset',
        'prevention': 'Multi-oracle (Chainlink + TWAP), circuit breakers'
    },
    {
        'id': 'FORTRESS_DAO_2022',
        'protocol': 'Fortress DAO',
        'date': '2022-05-09',
        'amount_usd': 3000000,
        'attack_type': 'Price Oracle Exploit',
        'pattern': 'oracle_manipulation',
        'vulnerable_code_pattern': 'Uniswap V2 spot price manipulation',
        'description': 'Flash loan to manipulate Uniswap V2 reserves, inflated collateral',
        'root_cause': 'Spot price oracle from low liquidity pool',
        'prevention': 'TWAP (30+ min), Chainlink, liquidity thresholds'
    },
    {
        'id': 'SADDLE_FINANCE_2022',
        'protocol': 'Saddle Finance',
        'date': '2022-04-30',
        'amount_usd': 10000000,
        'attack_type': 'Swap Math Exploit',
        'pattern': 'flash_loan_price_manipulation',
        'vulnerable_code_pattern': 'Missing slippage check in swap',
        'description': 'Exploited swap calculation, repeatedly swapped to drain pool',
        'root_cause': 'Swap math error, no min output check',
        'prevention': 'Rigorous math audits, slippage limits, invariant checks'
    },
    {
        'id': 'ELEPHANT_MONEY_2022',
        'protocol': 'Elephant Money',
        'date': '2022-04-12',
        'amount_usd': 22700000,
        'attack_type': 'Flash Loan Attack',
        'pattern': 'flash_loan_price_manipulation',
        'vulnerable_code_pattern': 'Collateral ratio manipulation via flash loan',
        'description': 'Flash loan to artificially boost collateral, minted stablecoin, dumped',
        'root_cause': 'Flash loan enabled collateral inflation',
        'prevention': 'Flash loan detection, collateral time-lock'
    },
    {
        'id': 'FEGTOKEN_2023',
        'protocol': 'FEGtoken',
        'date': '2023-05-16',
        'amount_usd': 1300000,
        'attack_type': 'Unverified External Call',
        'pattern': 'access_control',
        'vulnerable_code_pattern': 'Arbitrary delegatecall to user input',
        'description': 'Allowed arbitrary delegatecall, attacker called selfdestruct',
        'root_cause': 'Unchecked delegatecall, no whitelist',
        'prevention': 'Whitelist external calls, no arbitrary delegatecall'
    },
    {
        'id': 'HUNDRED_FINANCE_2022',
        'protocol': 'Hundred Finance',
        'date': '2022-04-15',
        'amount_usd': 7400000,
        'attack_type': 'Donation Attack',
        'pattern': 'flash_loan_price_manipulation',
        'vulnerable_code_pattern': 'ERC4626 donation to inflate share price',
        'description': 'Donated tokens to vault, inflated share price, withdrew more',
        'root_cause': 'Share price calculation using donated balance',
        'prevention': 'Virtual shares, donation inflation guard'
    },
    {
        'id': 'SLOPE_WALLET_2022',
        'protocol': 'Slope Wallet (Solana)',
        'date': '2022-08-03',
        'amount_usd': 8000000,
        'attack_type': 'Private Key Leak',
        'pattern': 'access_control',
        'vulnerable_code_pattern': 'Private keys logged to Sentry',
        'description': 'Mobile wallet accidentally sent private keys to Sentry logging',
        'root_cause': 'Insecure logging, private key exposure',
        'prevention': 'Never log secrets, encryption at rest'
    },
    {
        'id': 'AUDIUS_2022',
        'protocol': 'Audius',
        'date': '2022-07-23',
        'amount_usd': 6000000,
        'attack_type': 'Initialization Bug',
        'pattern': 'access_control',
        'vulnerable_code_pattern': 'Uninitialized proxy allowed re-initialization',
        'description': 'Exploited uninitialized storage slot to call initialize again',
        'root_cause': 'Missing initializer modifier on proxy',
        'prevention': 'Proper initialization checks, initializer modifier'
    },
    {
        'id': 'METER_IO_2022',
        'protocol': 'Meter.io Bridge',
        'date': '2022-02-06',
        'amount_usd': 4400000,
        'attack_type': 'Bridge Exploit',
        'pattern': 'cross_chain_bridge',
        'vulnerable_code_pattern': 'Missing deposit validation',
        'description': 'Manipulated deposit proof, minted tokens without locking collateral',
        'root_cause': 'Insufficient bridge deposit verification',
        'prevention': 'Multi-signature verification, deposit proof validation'
    },
    {
        'id': 'OASIS_PROTOCOL_2022',
        'protocol': 'Oasis Protocol Wormhole',
        'date': '2022-02-02',
        'amount_usd': 0,  # Same as Wormhole main
        'attack_type': 'Signature Verification',
        'pattern': 'cross_chain_bridge',
        'vulnerable_code_pattern': 'Guardian signature bypass',
        'description': 'Part of larger Wormhole exploit',
        'root_cause': 'Signature verification bypass',
        'prevention': 'Proper signature checks, guardian threshold'
    },
    {
        'id': 'MULTICHAIN_2023',
        'protocol': 'Multichain (Anyswap)',
        'date': '2023-07-07',
        'amount_usd': 126000000,
        'attack_type': 'Key Compromise',
        'pattern': 'access_control',
        'vulnerable_code_pattern': 'MPC keys compromised',
        'description': 'MPC network keys compromised, unauthorized withdrawals',
        'root_cause': 'Centralized MPC key management',
        'prevention': 'Decentralized MPC, key rotation, monitoring'
    },
    {
        'id': 'EULER_FINANCE_2023',
        'protocol': 'Euler Finance',
        'date': '2023-03-13',
        'amount_usd': 197000000,
        'attack_type': 'Donation Attack + Flash Loan',
        'pattern': 'flash_loan_price_manipulation',
        'vulnerable_code_pattern': 'Health check calculated with donated collateral',
        'description': 'Donated eTokens, took massive flash loan, liquidated self with profit',
        'root_cause': 'Donation inflated health factor',
        'prevention': 'Ignore donations in health calculations'
    },
    {
        'id': 'SENTIMENT_2023',
        'protocol': 'Sentiment',
        'date': '2023-04-04',
        'amount_usd': 1000000,
        'attack_type': 'Reentrancy',
        'pattern': 'reentrancy',
        'vulnerable_code_pattern': 'Balancer pool reentrancy on withdraw',
        'description': 'Reentered through Balancer callback, withdrew before debt update',
        'root_cause': 'External call to Balancer before state update',
        'prevention': 'ReentrancyGuard, checks-effects-interactions'
    }
]

def main():
    # Load existing database
    base_dir = Path(__file__).resolve().parent.parent
    db_path = base_dir / 'intelligence/database/exploit_database.json'

    with open(db_path) as f:
        data = json.load(f)

    exploits = data if isinstance(data, list) else data.get('exploits', [])

    print(f"\nExisting exploits: {len(exploits)}")
    print(f"Adding new exploits: {len(NEW_EXPLOITS)}")

    # Add new exploits
    exploits.extend(NEW_EXPLOITS)

    print(f"Total exploits: {len(exploits)}")

    # Calculate total losses
    total_loss = sum(e['amount_usd'] for e in exploits)
    print(f"Total documented losses: ${total_loss:,}")

    # Save updated database
    output = {
        'version': '2.0',
        'last_updated': datetime.now().isoformat(),
        'total_exploits': len(exploits),
        'total_loss_usd': total_loss,
        'exploits': exploits
    }

    with open(db_path, 'w') as f:
        json.dump(output, f, indent=2)

    print(f"\n✅ Database updated: {db_path}")

    # Summary by pattern
    patterns = {}
    for exploit in exploits:
        pattern = exploit.get('pattern', 'unknown')
        if pattern not in patterns:
            patterns[pattern] = {'count': 0, 'total_loss': 0}
        patterns[pattern]['count'] += 1
        patterns[pattern]['total_loss'] += exploit['amount_usd']

    print("\nExploits by pattern:")
    for pattern, stats in sorted(patterns.items(), key=lambda x: x[1]['total_loss'], reverse=True):
        print(f"  {pattern}: {stats['count']} exploits, ${stats['total_loss']:,}")


if __name__ == '__main__':
    main()
