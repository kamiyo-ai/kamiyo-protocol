//! Solana ZK Proof Verification
//!
//! This module provides utilities for verifying ZK proofs on Solana.
//!
//! ## Dual ZK Architecture
//!
//! Mitama uses two complementary ZK systems:
//!
//! ### 1. Halo2 (Zcash) - Trustless Commitments
//! - No trusted setup required
//! - Used for privacy guarantees during commit phase
//! - Proofs verified off-chain
//!
//! ### 2. Circom/Groth16 - On-chain Verification
//! - Native Solana support via `alt_bn128` syscalls
//! - ~200k compute units for verification
//! - Used for settlement finality
//!
//! ## Flow
//!
//! ```text
//! 1. Commit Phase  → Halo2 commitment (trustless, no ceremony)
//! 2. Reveal Phase  → Circom/Groth16 proof generation
//! 3. On-chain      → groth16-solana verification (~200k CU)
//! ```
//!
//! ## References
//!
//! - [groth16-solana](https://github.com/Lightprotocol/groth16-solana)
//! - [circom](https://github.com/iden3/circom)
//! - [Solana alt_bn128](https://www.helius.dev/blog/zero-knowledge-proofs-its-applications-on-solana)

use serde::{Deserialize, Serialize};

/// A proof that can be submitted to Solana
///
/// For now, this is a commitment-based proof.
/// Future: Will wrap a Groth16 proof for native verification.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SolanaProof {
    /// The commitment hash (Poseidon)
    pub commitment: [u8; 32],
    /// The score being revealed
    pub score: u8,
    /// The blinding factor for verification
    pub blinding: [u8; 32],
    /// Escrow ID this vote is for
    pub escrow_id: [u8; 32],
    /// Oracle public key
    pub oracle: [u8; 32],
}

impl SolanaProof {
    /// Create a new Solana proof from revealed values
    pub fn new(
        commitment: [u8; 32],
        score: u8,
        blinding: [u8; 32],
        escrow_id: [u8; 32],
        oracle: [u8; 32],
    ) -> Self {
        Self {
            commitment,
            score,
            blinding,
            escrow_id,
            oracle,
        }
    }

    /// Serialize for Solana instruction data
    pub fn to_instruction_data(&self) -> Vec<u8> {
        bincode::serialize(self).expect("serialization should not fail")
    }

    /// Deserialize from Solana instruction data
    pub fn from_instruction_data(data: &[u8]) -> Result<Self, bincode::Error> {
        bincode::deserialize(data)
    }
}

/// Verify a commitment matches the revealed values
///
/// This is the on-chain verification logic (simplified for Rust).
/// The actual Solana program would implement this in the instruction handler.
pub fn verify_commitment(
    commitment: &[u8; 32],
    score: u8,
    blinding: &[u8; 32],
    escrow_id: &[u8; 32],
    oracle: &[u8; 32],
) -> bool {
    use crate::commitment::VoteCommitment;

    let computed = VoteCommitment::compute_hash(score, blinding, escrow_id, oracle);
    computed == *commitment
}

/// Groth16 proof for native Solana verification
///
/// Generated by circom/snarkjs, verified by groth16-solana.
/// Uses BN254 curve (alt_bn128) which has native Solana syscall support.
///
/// ## Structure
/// - proof_a: G1 point (64 bytes) - uncompressed
/// - proof_b: G2 point (128 bytes) - uncompressed
/// - proof_c: G1 point (64 bytes) - uncompressed
///
/// ## Usage
/// ```ignore
/// use mitama_zk::solana::Groth16Proof;
///
/// // From snarkjs proof JSON
/// let proof = Groth16Proof::from_snarkjs(&proof_json)?;
///
/// // Get instruction data for Solana
/// let ix_data = proof.to_instruction_data();
/// ```
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Groth16Proof {
    /// G1 point A (64 bytes, big-endian)
    pub proof_a: Vec<u8>,
    /// G2 point B (128 bytes, big-endian)
    pub proof_b: Vec<u8>,
    /// G1 point C (64 bytes, big-endian)
    pub proof_c: Vec<u8>,
    /// Public inputs (32 bytes each, big-endian)
    pub public_inputs: Vec<Vec<u8>>,
}

impl Groth16Proof {
    /// Expected sizes
    pub const PROOF_A_SIZE: usize = 64;
    pub const PROOF_B_SIZE: usize = 128;
    pub const PROOF_C_SIZE: usize = 64;
    pub const PUBLIC_INPUT_SIZE: usize = 32;

    /// Create a new Groth16 proof
    pub fn new(
        proof_a: Vec<u8>,
        proof_b: Vec<u8>,
        proof_c: Vec<u8>,
        public_inputs: Vec<Vec<u8>>,
    ) -> Self {
        Self {
            proof_a,
            proof_b,
            proof_c,
            public_inputs,
        }
    }

    /// Create an empty proof (for testing)
    pub fn empty() -> Self {
        Self {
            proof_a: vec![0u8; Self::PROOF_A_SIZE],
            proof_b: vec![0u8; Self::PROOF_B_SIZE],
            proof_c: vec![0u8; Self::PROOF_C_SIZE],
            public_inputs: vec![],
        }
    }

    /// Serialize for Solana instruction data
    pub fn to_instruction_data(&self) -> Vec<u8> {
        bincode::serialize(self).expect("serialization should not fail")
    }

    /// Deserialize from Solana instruction data
    pub fn from_instruction_data(data: &[u8]) -> Result<Self, bincode::Error> {
        bincode::deserialize(data)
    }

    /// Total proof size in bytes (without public inputs)
    pub const PROOF_SIZE: usize = 64 + 128 + 64; // 256 bytes

    /// Validate proof structure
    pub fn is_valid_structure(&self) -> bool {
        self.proof_a.len() == Self::PROOF_A_SIZE
            && self.proof_b.len() == Self::PROOF_B_SIZE
            && self.proof_c.len() == Self::PROOF_C_SIZE
            && self.public_inputs.iter().all(|p| p.len() == Self::PUBLIC_INPUT_SIZE)
    }
}

/// Oracle vote public inputs for Groth16 verification
///
/// These match the public signals from the circom circuit.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct OracleVotePublicInputs {
    /// Escrow ID being voted on
    pub escrow_id: [u8; 32],
    /// Oracle's public key
    pub oracle_pk: [u8; 32],
    /// Expected commitment hash
    pub expected_commitment: [u8; 32],
    /// Valid flag (should be 1)
    pub valid: [u8; 32],
}

impl OracleVotePublicInputs {
    /// Convert to array format for groth16-solana
    pub fn to_array(&self) -> [[u8; 32]; 4] {
        [
            self.escrow_id,
            self.oracle_pk,
            self.expected_commitment,
            self.valid,
        ]
    }
}

/// Compute units estimate for Solana verification
pub mod compute_units {
    /// Commitment verification (Blake2b hash comparison)
    pub const COMMITMENT_VERIFY: u64 = 5_000;

    /// Groth16 verification on BN254 (future)
    /// Based on Solana's alt_bn128 benchmarks
    pub const GROTH16_VERIFY: u64 = 200_000;

    /// Poseidon hash computation
    pub const POSEIDON_HASH: u64 = 10_000;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_solana_proof_serialization() {
        let proof = SolanaProof::new(
            [1u8; 32],
            75,
            [2u8; 32],
            [3u8; 32],
            [4u8; 32],
        );

        let data = proof.to_instruction_data();
        let recovered = SolanaProof::from_instruction_data(&data).unwrap();

        assert_eq!(proof.score, recovered.score);
        assert_eq!(proof.commitment, recovered.commitment);
    }

    #[test]
    fn test_verify_commitment() {
        let score = 75u8;
        let blinding = [1u8; 32];
        let escrow_id = [2u8; 32];
        let oracle = [3u8; 32];

        // Compute the commitment
        use crate::commitment::VoteCommitment;
        let commitment = VoteCommitment::compute_hash(score, &blinding, &escrow_id, &oracle);

        // Verify it
        assert!(verify_commitment(&commitment, score, &blinding, &escrow_id, &oracle));

        // Wrong score should fail
        assert!(!verify_commitment(&commitment, 74, &blinding, &escrow_id, &oracle));
    }
}
