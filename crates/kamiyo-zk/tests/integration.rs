//! Integration tests for the full ZK flow
//!
//! Tests the complete commit → prove → verify flow for oracle voting.

use kamiyo_zk::{
    bridge::{CircomInputs, SolanaVerificationData},
    commitment::{generate_blinding, VoteCommitment},
    prover::OracleVoteProver,
    solana::{verify_commitment, Groth16Proof},
    ZkError, MAX_SCORE, MIN_SCORE,
};

/// Test the complete Halo2 flow: setup → commit → prove → verify
#[test]
fn test_halo2_full_flow() {
    // Setup prover (one-time operation)
    let prover = OracleVoteProver::setup().expect("Prover setup should succeed");

    // Oracle's vote parameters
    let score = 75u8;
    let blinding = generate_blinding().expect("RNG should work");
    let escrow_id = [0x42u8; 32]; // Example escrow ID
    let oracle_pk = [0x13u8; 32]; // Example oracle public key

    // Phase 1: Commit
    let commitment = prover
        .commit(score, &blinding, escrow_id, oracle_pk)
        .expect("Commitment should succeed");

    // Verify commitment can be verified later
    assert!(
        commitment.verify(score, &blinding),
        "Commitment should verify with correct values"
    );
    assert!(
        !commitment.verify(76, &blinding),
        "Commitment should not verify with wrong score"
    );

    // Phase 2: Prove (after reveal delay)
    let proof = prover
        .prove(score, &blinding, &commitment)
        .expect("Proof generation should succeed");

    // Phase 3: Verify
    let is_valid = prover
        .verify(&proof, &commitment)
        .expect("Verification should not error");
    assert!(is_valid, "Valid proof should verify");

    // Test proof serialization roundtrip
    let proof_bytes = proof.to_bytes();
    let recovered_proof =
        kamiyo_zk::prover::Halo2Proof::from_bytes(&proof_bytes).expect("Proof deserialization");
    assert_eq!(proof.bytes, recovered_proof.bytes);
}

/// Test the bridge to Circom/Groth16
#[test]
fn test_bridge_to_circom() {
    let score = 50u8;
    let blinding = [0xABu8; 32];
    let escrow_id = [0x01u8; 32];
    let oracle_pk = [0x02u8; 32];

    let commitment = VoteCommitment::new(score, &blinding, escrow_id, oracle_pk);

    // Generate Circom inputs
    let circom_inputs = CircomInputs::from_commitment(&commitment, score, &blinding)
        .expect("Circom inputs should be created");

    // Verify fields are set correctly
    assert_eq!(circom_inputs.score, "50");

    // Serialize to JSON (for snarkjs)
    let json = circom_inputs.to_json().expect("JSON serialization");
    assert!(json.contains("\"score\": \"50\""));
    assert!(json.contains("escrow_id"));
    assert!(json.contains("oracle_pk"));
    assert!(json.contains("expected_commitment"));
    assert!(json.contains("blinding"));
}

/// Test Solana verification data structure
#[test]
fn test_solana_verification_data() {
    let score = 80u8;
    let blinding = [0xCDu8; 32];
    let escrow_id = [0x11u8; 32];
    let oracle_pk = [0x22u8; 32];

    let commitment = VoteCommitment::new(score, &blinding, escrow_id, oracle_pk);

    // Create empty Groth16 proof (would be generated by snarkjs in real flow)
    let groth16_proof = Groth16Proof::empty();

    // Create Solana verification data
    let verification_data = SolanaVerificationData::new(groth16_proof, &commitment, score)
        .expect("Verification data should be created");

    // Verify structure
    assert_eq!(verification_data.score, 80);
    assert_eq!(verification_data.commitment, commitment.hash);
    assert_eq!(verification_data.public_inputs.len(), 4);

    // Check public inputs order: [escrow_id, oracle_pk, commitment, valid]
    assert_eq!(verification_data.public_inputs[0], escrow_id);
    assert_eq!(verification_data.public_inputs[1], oracle_pk);
    assert_eq!(verification_data.public_inputs[2], commitment.hash);
    // valid = 1
    let mut expected_valid = [0u8; 32];
    expected_valid[31] = 1;
    assert_eq!(verification_data.public_inputs[3], expected_valid);

    // Test serialization
    let ix_data = verification_data
        .to_instruction_data()
        .expect("Serialization");
    assert!(!ix_data.is_empty());
}

/// Test off-chain commitment verification (used before on-chain settlement)
#[test]
fn test_offchain_commitment_verification() {
    let score = 100u8;
    let blinding = [0xEFu8; 32];
    let escrow_id = [0x33u8; 32];
    let oracle_pk = [0x44u8; 32];

    let commitment = VoteCommitment::compute_hash(score, &blinding, &escrow_id, &oracle_pk);

    // Verify commitment matches
    assert!(verify_commitment(
        &commitment,
        score,
        &blinding,
        &escrow_id,
        &oracle_pk
    ));

    // Wrong score should fail
    assert!(!verify_commitment(
        &commitment,
        99,
        &blinding,
        &escrow_id,
        &oracle_pk
    ));

    // Wrong blinding should fail
    assert!(!verify_commitment(
        &commitment,
        score,
        &[0x00u8; 32],
        &escrow_id,
        &oracle_pk
    ));
}

/// Test score boundary conditions
#[test]
fn test_score_boundaries() {
    let prover = OracleVoteProver::setup().expect("Prover setup");
    let blinding = generate_blinding().expect("RNG");
    let escrow_id = [0x55u8; 32];
    let oracle_pk = [0x66u8; 32];

    // MIN_SCORE (0) should work
    let commitment_min = prover.commit(MIN_SCORE, &blinding, escrow_id, oracle_pk);
    assert!(commitment_min.is_ok());

    // MAX_SCORE (100) should work
    let commitment_max = prover.commit(MAX_SCORE, &blinding, escrow_id, oracle_pk);
    assert!(commitment_max.is_ok());

    // Score above MAX_SCORE (101) should fail
    let commitment_invalid = prover.commit(101, &blinding, escrow_id, oracle_pk);
    assert!(commitment_invalid.is_err());

    // Verify the error type
    match commitment_invalid {
        Err(ZkError::InvalidScore(s)) => assert_eq!(s, 101),
        _ => panic!("Expected InvalidScore error"),
    }
}

/// Test multiple votes with different scores
#[test]
fn test_multiple_votes() {
    let prover = OracleVoteProver::setup().expect("Prover setup");
    let escrow_id = [0x77u8; 32];
    let oracle_pk = [0x88u8; 32];

    let scores = [0, 25, 50, 75, 100];

    for score in scores {
        let blinding = generate_blinding().expect("RNG");
        let commitment = prover
            .commit(score, &blinding, escrow_id, oracle_pk)
            .expect("Commitment");

        let proof = prover.prove(score, &blinding, &commitment).expect("Proof");

        let valid = prover.verify(&proof, &commitment).expect("Verify");
        assert!(valid, "Score {} should verify", score);
    }
}

/// Test commitment uniqueness (different blinding = different commitment)
#[test]
fn test_commitment_uniqueness() {
    let score = 50u8;
    let escrow_id = [0x99u8; 32];
    let oracle_pk = [0xAAu8; 32];

    let blinding1 = [0x01u8; 32];
    let blinding2 = [0x02u8; 32];

    let commitment1 = VoteCommitment::new(score, &blinding1, escrow_id, oracle_pk);
    let commitment2 = VoteCommitment::new(score, &blinding2, escrow_id, oracle_pk);

    // Same score but different blinding should produce different commitments
    assert_ne!(
        commitment1.hash, commitment2.hash,
        "Different blinding should produce different commitments"
    );

    // Each commitment should only verify with its own blinding
    assert!(commitment1.verify(score, &blinding1));
    assert!(!commitment1.verify(score, &blinding2));
    assert!(commitment2.verify(score, &blinding2));
    assert!(!commitment2.verify(score, &blinding1));
}

/// Test commitment binding (cannot change score after commitment)
#[test]
fn test_commitment_binding() {
    let prover = OracleVoteProver::setup().expect("Prover setup");

    let original_score = 75u8;
    let blinding = generate_blinding().expect("RNG");
    let escrow_id = [0xBBu8; 32];
    let oracle_pk = [0xCCu8; 32];

    let commitment = prover
        .commit(original_score, &blinding, escrow_id, oracle_pk)
        .expect("Commitment");

    // Cannot prove a different score with the same blinding
    // (the commitment won't match)
    let modified_score = 90u8;

    // The commitment verification should fail
    assert!(
        !commitment.verify(modified_score, &blinding),
        "Modified score should not verify"
    );

    // Original score should still verify
    assert!(
        commitment.verify(original_score, &blinding),
        "Original score should verify"
    );
}
