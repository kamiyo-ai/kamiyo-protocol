#!/usr/bin/env python3
"""
Agent 2: Historical Exploit Database
Build comprehensive database of past exploits with attack patterns
"""

import json
from pathlib import Path
from datetime import datetime

class ExploitDatabase:
    """Historical exploit database builder"""

    def __init__(self):
        self.output_dir = Path('intelligence/database')
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def build_historical_database(self):
        """Build database of well-documented historical exploits"""

        # Major exploits with known attack patterns (2020-2025)
        exploits = [
            {
                'id': 'WORMHOLE_2022',
                'protocol': 'Wormhole Bridge',
                'date': '2022-02-02',
                'amount_usd': 326000000,
                'chain': 'Ethereum/Solana',
                'attack_type': 'Signature Verification Bypass',
                'pattern': 'cross_chain_bridge',
                'description': 'Attacker bypassed signature verification in cross-chain message validation',
                'vulnerable_code_pattern': 'verify_signatures without proper account checks',
                'root_cause': 'Missing sysvar account validation in Solana program',
                'exploit_technique': 'Forged guardian signatures by exploiting missing account validation',
                'references': ['https://rekt.news/wormhole-rekt/'],
                'similar_protocols': ['Multichain', 'Synapse', 'Hop Protocol']
            },
            {
                'id': 'RONIN_2022',
                'protocol': 'Ronin Bridge',
                'date': '2022-03-23',
                'amount_usd': 625000000,
                'chain': 'Ethereum/Ronin',
                'attack_type': 'Compromised Validator Keys',
                'pattern': 'cross_chain_bridge',
                'description': 'Attackers compromised 5/9 validator keys to approve fraudulent withdrawals',
                'vulnerable_code_pattern': 'Multi-sig with low threshold + centralized validators',
                'root_cause': 'Insufficient validator decentralization + social engineering',
                'exploit_technique': 'Compromised private keys â†’ signed fake withdrawal transactions',
                'references': ['https://rekt.news/ronin-rekt/'],
                'similar_protocols': ['Polygon Bridge', 'Boba Network']
            },
            {
                'id': 'EULER_2023',
                'protocol': 'Euler Finance',
                'date': '2023-03-13',
                'amount_usd': 197000000,
                'chain': 'Ethereum',
                'attack_type': 'Donation Attack',
                'pattern': 'flash_loan_donation',
                'description': 'Flash loan + donation to manipulate health factor calculation',
                'vulnerable_code_pattern': 'donateToReserves without balance change tracking',
                'root_cause': 'Donation function updated internal accounting without actual token transfer validation',
                'exploit_technique': '1. Flash loan, 2. Donate to inflate collateral, 3. Borrow against fake collateral, 4. Liquidate self',
                'references': ['https://rekt.news/euler-rekt/'],
                'similar_protocols': ['Aave', 'Compound', 'Radiant']
            },
            {
                'id': 'MANGO_2022',
                'protocol': 'Mango Markets',
                'date': '2022-10-11',
                'amount_usd': 110000000,
                'chain': 'Solana',
                'attack_type': 'Oracle Price Manipulation',
                'pattern': 'oracle_manipulation',
                'description': 'Manipulated oracle price through low-liquidity perpetual markets',
                'vulnerable_code_pattern': 'Oracle relies on on-chain TWAP from manipulatable market',
                'root_cause': 'Oracle price derived from thin liquidity perp market',
                'exploit_technique': '1. Build large perp position, 2. Pump price with small capital, 3. Borrow against inflated collateral',
                'references': ['https://rekt.news/mango-markets-rekt/'],
                'similar_protocols': ['Drift Protocol', 'Zeta Markets']
            },
            {
                'id': 'POLY_NETWORK_2021',
                'protocol': 'Poly Network',
                'date': '2021-08-10',
                'amount_usd': 611000000,
                'chain': 'Multi-chain',
                'attack_type': 'Access Control Bypass',
                'pattern': 'access_control',
                'description': 'Called privileged function through cross-chain message',
                'vulnerable_code_pattern': 'EthCrossChainManager allowed arbitrary contract calls',
                'root_cause': 'Missing access control on cross-chain message handler',
                'exploit_technique': 'Send malicious cross-chain message â†’ call keeper contract â†’ extract funds',
                'references': ['https://rekt.news/polynetwork-rekt/'],
                'similar_protocols': ['Anyswap', 'cBridge']
            },
            {
                'id': 'CREAM_2021',
                'protocol': 'Cream Finance',
                'date': '2021-10-27',
                'amount_usd': 130000000,
                'chain': 'Ethereum',
                'attack_type': 'Reentrancy',
                'pattern': 'reentrancy',
                'description': 'Reentrancy on yUSD deposit/withdrawal',
                'vulnerable_code_pattern': 'External call before state update in lending market',
                'root_cause': 'Missing reentrancy guard on liquidation function',
                'exploit_technique': 'Flash loan â†’ deposit â†’ reenter during callback â†’ borrow â†’ repay with less',
                'references': ['https://rekt.news/cream-rekt-2/'],
                'similar_protocols': ['Venus', 'Moonwell']
            },
            {
                'id': 'NOMAD_2022',
                'protocol': 'Nomad Bridge',
                'date': '2022-08-01',
                'amount_usd': 190000000,
                'chain': 'Multi-chain',
                'attack_type': 'Merkle Root Validation Bypass',
                'pattern': 'cross_chain_bridge',
                'description': 'Zero hash allowed as valid merkle root during upgrade',
                'vulnerable_code_pattern': 'committedRoot initialized to 0x0 after upgrade',
                'root_cause': 'Upgrade set trusted root to 0x0, allowing any message to validate',
                'exploit_technique': 'Submit arbitrary messages with 0x0 merkle proof â†’ passed validation',
                'references': ['https://rekt.news/nomad-rekt/'],
                'similar_protocols': ['Connext', 'Celer']
            },
            {
                'id': 'GMX_2023',
                'protocol': 'GMX V2',
                'date': '2023-09-01',
                'amount_usd': 42000000,
                'chain': 'Arbitrum/Avalanche',
                'attack_type': 'Price Oracle Manipulation during Settlement',
                'pattern': 'oracle_manipulation',
                'description': 'Exploited price update mechanism during position settlement',
                'vulnerable_code_pattern': 'Liquidation price not protected against flash manipulation',
                'root_cause': 'Oracle price update timing allowed manipulation during settlement',
                'exploit_technique': 'Manipulate price â†’ trigger liquidation â†’ front-run settlement',
                'references': ['https://cryptoslate.com/gmx-protocol-suffers-565k-exploit/'],
                'similar_protocols': ['Gains Network', 'Kwenta', 'Level Finance']
            },
            {
                'id': 'TRANSIT_SWAP_2022',
                'protocol': 'Transit Swap',
                'date': '2022-10-01',
                'amount_usd': 21000000,
                'chain': 'Multi-chain',
                'attack_type': 'Arbitrary External Call',
                'pattern': 'access_control',
                'description': 'Arbitrary call to user-supplied contract address',
                'vulnerable_code_pattern': 'transferFrom(userContract) without validation',
                'root_cause': 'Missing validation on external contract calls',
                'exploit_technique': 'Pass malicious contract address â†’ call transferFrom on victim tokens',
                'references': ['https://rekt.news/transit-swap-rekt/'],
                'similar_protocols': ['1inch', 'ParaSwap']
            },
            {
                'id': 'BNB_BRIDGE_2022',
                'protocol': 'BNB Chain Bridge',
                'date': '2022-10-06',
                'amount_usd': 586000000,
                'chain': 'BNB Chain',
                'attack_type': 'Merkle Proof Forgery',
                'pattern': 'cross_chain_bridge',
                'description': 'Forged proof to mint BNB on BSC side',
                'vulnerable_code_pattern': 'Insufficient proof verification in bridge contract',
                'root_cause': 'Bug in IAVL proof verification allowed forged proofs',
                'exploit_technique': 'Crafted fake proof â†’ verified as valid â†’ minted 2M BNB',
                'references': ['https://rekt.news/bnb-bridge-rekt/'],
                'similar_protocols': ['Gravity Bridge']
            }
        ]

        # Add attack pattern taxonomy
        pattern_taxonomy = {
            'reentrancy': {
                'description': 'External calls before state updates allow reentrant attacks',
                'detection_patterns': ['call before state update', 'missing reentrancy guard', 'callback manipulation'],
                'prevention': 'Checks-Effects-Interactions pattern, ReentrancyGuard modifier',
                'exploits_count': len([e for e in exploits if e['pattern'] == 'reentrancy'])
            },
            'oracle_manipulation': {
                'description': 'Manipulating price oracles through flash loans or thin liquidity',
                'detection_patterns': ['spot price without TWAP', 'single DEX oracle', 'manipulatable liquidity'],
                'prevention': 'Time-weighted prices, multiple oracle sources, liquidity thresholds',
                'exploits_count': len([e for e in exploits if e['pattern'] == 'oracle_manipulation'])
            },
            'cross_chain_bridge': {
                'description': 'Bridge-specific vulnerabilities in message passing and validation',
                'detection_patterns': ['signature verification bypass', 'merkle proof forgery', 'validator compromise'],
                'prevention': 'Multi-sig with high threshold, proper account validation, challenge periods',
                'exploits_count': len([e for e in exploits if e['pattern'] == 'cross_chain_bridge'])
            },
            'access_control': {
                'description': 'Missing or bypassable access control checks',
                'detection_patterns': ['missing onlyOwner', 'arbitrary external call', 'delegatecall to user input'],
                'prevention': 'Proper access modifiers, input validation, allowlist patterns',
                'exploits_count': len([e for e in exploits if e['pattern'] == 'access_control'])
            },
            'flash_loan_donation': {
                'description': 'Donation or accounting manipulation via flash loans',
                'detection_patterns': ['donation without balance check', 'share price manipulation', 'inflation attack'],
                'prevention': 'Validate actual balance changes, minimum deposit requirements',
                'exploits_count': len([e for e in exploits if e['pattern'] == 'flash_loan_donation'])
            }
        }

        # Save database
        database = {
            'version': '1.0',
            'last_updated': datetime.now().isoformat(),
            'total_exploits': len(exploits),
            'total_amount_usd': sum(e['amount_usd'] for e in exploits),
            'pattern_taxonomy': pattern_taxonomy,
            'exploits': exploits
        }

        db_file = self.output_dir / 'exploit_database.json'
        with open(db_file, 'w') as f:
            json.dump(database, f, indent=2)

        print(f"âœ… Built historical database:")
        print(f"   Total exploits: {len(exploits)}")
        print(f"   Total value lost: ${sum(e['amount_usd'] for e in exploits):,.0f}")
        print(f"   Attack patterns: {len(pattern_taxonomy)}")
        print(f"   Saved to: {db_file}")

        return database

    def run(self):
        """Build database"""
        print("="*70)
        print("EXPLOIT DATABASE - AGENT 2")
        print("="*70)

        database = self.build_historical_database()

        # Generate quick reference
        reference = {
            'patterns': list(database['pattern_taxonomy'].keys()),
            'top_10_exploits': sorted(
                database['exploits'],
                key=lambda x: x['amount_usd'],
                reverse=True
            )[:10]
        }

        ref_file = self.output_dir / 'quick_reference.json'
        with open(ref_file, 'w') as f:
            json.dump(reference, f, indent=2)

        print(f"\nðŸ“– Quick reference: {ref_file}")

if __name__ == '__main__':
    builder = ExploitDatabase()
    builder.run()
