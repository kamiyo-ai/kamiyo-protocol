// pages/api/exploits.js
import { getSession } from "next-auth/react";
import prisma from "../../lib/prisma";
import { withRateLimit } from "../../lib/rateLimit";

async function handler(req, res) {
    const API_URL = process.env.FASTAPI_URL || 'http://127.0.0.1:8000';

    try {
        // Check authentication
        const session = await getSession({ req });

        let tier = 'free';
        let applyDelay = true;

        // If user is authenticated, fetch their subscription tier
        if (session?.user?.email) {
            const user = await prisma.user.findUnique({
                where: { email: session.user.email },
                select: { id: true },
            });

            if (user) {
                const subscription = await prisma.subscription.findFirst({
                    where: {
                        userId: user.id,
                        status: 'active'
                    },
                    select: { tier: true },
                    orderBy: { createdAt: 'desc' },
                });

                tier = subscription?.tier || 'free';
                // Only free tier gets delayed data
                applyDelay = tier === 'free';
            }
        }

        // Fetch data from backend API
        const queryParams = new URLSearchParams(req.query);
        const response = await fetch(`${API_URL}/exploits?${queryParams}`);
        const data = await response.json();

        // Apply 24-hour delay for free tier
        if (applyDelay && data.data) {
            const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
            data.data = data.data.filter(exploit => {
                const exploitDate = new Date(exploit.timestamp || exploit.date);
                return exploitDate <= twentyFourHoursAgo;
            });

            // Add metadata indicating delayed data
            data.metadata = {
                ...data.metadata,
                tier,
                delayed: true,
                delay_hours: 24
            };
        } else if (data.data) {
            data.metadata = {
                ...data.metadata,
                tier,
                delayed: false
            };
        }

        res.status(200).json(data);
    } catch (error) {
        console.error('Error fetching exploits:', error);
        res.status(500).json({ error: 'Failed to fetch exploits' });
    }
}

export default withRateLimit(handler);
